// Implement surface and surface point class
#include "surface.h"

#include <string>
#include <iostream>
#include <fstream>

#include <cstdio>
#include <cmath>
#include <util/parms.h>

using std::cout;
using std::cerr;
using std::endl;

// Clip to bounds
static double InBounds(double s, double min, double max) 
{
  if(s < min)
    return(min);
  else if(s > max)
    return(max);
  else
    return(s);
}

//----------------------------------------------------------------

Point3d SurfacePoint::Pos()
{
  return(pos);
}

//----------------------------------------------------------------

Point3d SurfacePoint::Pos() const
{
  return(pos);
}

//----------------------------------------------------------------

Point3d SurfacePoint::Normal()
{
  return(normal);
}

//----------------------------------------------------------------

Surface::Surface( util::Parms &parms,
                  string section,
                  const bool bezierGrowthSurface,
                  const bool interpolateBezierSurfaces,
                  const std::string &surfaceName )
{
  this->init( parms, section, bezierGrowthSurface,
              interpolateBezierSurfaces, surfaceName );
}

//----------------------------------------------------------------

void Surface::init( util::Parms &parms,
                    string section,
                    const bool bezierGrowthSurface,
                    const bool interpolateBezierSurfaces,
                    const std::string &surfaceName )
{
  string surffile;

  time = 0;
  
  _bezierGrowthSurface = bezierGrowthSurface;
  
  // Load surfaces 
  parms(section.data(), "Surfaces", surfaces);
  parms(section.data(), "SurfTimeScale", surfTimeScale);
  parms(section.data(), "SurfMaxDist", surfMaxDist);
  if( !_bezierGrowthSurface )
  {
    for(int i = 0; i < surfaces; i++) {
      // Bezier surface
      std::ostringstream key;
      key << "Surface" << i;
      parms(section.data(), key.str().data(), surffile);
      surface[i].Load(surffile);
      // code to load bezier surface generated in MorphoGraphX
      //std::string name = surfaceName + std::to_string(i+1) + ".mgxv";
      //surface[i].Load( name );

      // Scaling constant
      key.str("");
      key << "SurfaceScale" << i;
      parms(section.data(), key.str().data(), surfScale[i]);

      // Time constant
      key.str("");
      key << "SurfaceTime" << i;
      parms(section.data(), key.str().data(), surfTime[i]);
    }
  }
  else
  {
    if( !interpolateBezierSurfaces )
    {
      std::string source = "/home/necrolyte/Data/VLR/Virtual_Lateral_Roots/Modelling/VirtualLateralRoot/bezierGrowthSurfaces/";
      this->determineSurfaceHeaderProperties( source + "header.txt" );
      
      for( std::size_t i = 0; i < _numSurfaces; i++ )
      {
        std::string digit;
        if( i < 10 )
          digit = "_00";
        else if( i < 100 )
          digit = digit = "_0";
        else
          digit = digit = "_";
        
        digit += std::to_string( i );
        std::string fileName = source + "bezierTensorSurface";
        fileName += digit;
        fileName += ".txt";
        
        // load bezier growth surface
        surface[i].LoadGrowthBezier( fileName, _numPatches, _numControlPoints );
      }
    }
    else
    {
      // Here, only load the first and last bezier surface while all surfaces
      // in between are generated by linear interpolation based on the number of
      // given surfaces numSurfaces
      std::string first = "bezierTensorSurfaceFirst.txt";
      std::string last = "bezierTensorSurfaceLast.txt";
      this->determineSurfaceHeaderProperties( "bezierHeader.txt" );
      
      // load bezier growth surfaces
      surface[0].LoadGrowthBezier( first, _numPatches, _numControlPoints );
      surface[_numSurfaces-1].LoadGrowthBezier( last, _numPatches, _numControlPoints );
      
      for( std::size_t i = 1; i < _numSurfaces-1; i++ )
      {
        double s = (double)i/(double)(_numSurfaces-1);
        surface[i].Interpolate( surface[0], surface[_numSurfaces-1], 1., 1., s );
        surface[i].setCount( 1 );
      }
    }
  }
}

//----------------------------------------------------------------

// only for bezier surfaces based on growth tensor
void Surface::determineSurfaceHeaderProperties( const std::string bezFile )
{
  std::ifstream bIn( bezFile.c_str() );
  if(!bIn) {
    cerr << "Bezier::Bezier:Error opening " << bezFile << endl;
    exit(1);
  }
  bIn >> _numSurfaces;
  bIn >> _numPatches;
  bIn >> _numControlPoints;
}

//----------------------------------------------------------------

// Zero a surface Point
void Surface::Zero(SurfacePoint &p)
{
  p.u = p.v = 0.0;
  CalcPos(p);
  CalcNormal(p);
}

//----------------------------------------------------------------

// Initial surface Point
void Surface::InitPoint(SurfacePoint &p, double u, double v)
{
  p.u = InBounds(u, 0.0, 1.0);
  p.v = InBounds(v, 0.0, 1.0);
  
  CalcPos(p);
  CalcNormal(p);
}

//----------------------------------------------------------------

// Determine parametric coords u and v such that the distance between
// the corresponding point for (u,v) is minimal to the desired point cp
bool Surface::SetPoint(SurfacePoint &p, SurfacePoint sp, Point3d cp)
{
  // Initial guess for p
  p.u = sp.u;
  p.v = sp.v;
  CalcPos(p);
  double lastd = -(DX * 1000);
  double count = 0;
  double du, dv;

  while(fabs(lastd - norm(cp - p.pos)) > DX * 2 && count++ < MAXSEARCHSTEPS)
  {
    // Save previous distance
    lastd = norm(cp - p.pos);

    // Calc partials
    SurfacePoint u1 = p, u2 = p;
    u1.u -= DX;
    u2.u += DX;
    CalcPos(u1);
    CalcPos(u2);
    du = (norm(cp - u1.pos) - norm(cp - u2.pos))/fabs(u1.u - u2.u);
    
    SurfacePoint v1 = p, v2 = p;
    v1.v -= DX;
    v2.v += DX;
    CalcPos(v1);
    CalcPos(v2);
    dv = (norm(cp - v1.pos) - norm(cp - v2.pos))/fabs(v1.v - v2.v);
    
    // Do line minimization
    double step = .01;
    while(step > DX)
    {
      SurfacePoint t = p;
      t.u += step * du;
      t.v += step * dv;
      CalcPos(t);
      if(norm(cp - t.pos) < norm(cp - p.pos))
      {
        step *= 1.11;
        p = t;
      }
      else
        step /= 2.0;
    }
  }

  CalcNormal(p);
  if(count >= MAXSEARCHSTEPS || norm(p.pos - cp) > surfMaxDist) {
    cerr << "Surface::SetPoint:Error Failed, point " << cp << 
            " closest point " << p.pos << " du " << du << " dv " << dv << 
            " count " << count << " distance " <<  norm(p.pos - cp) << endl;
  }

  return(true);
}

//----------------------------------------------------------------

// Advance time
void Surface::GrowStep(double dt)
{
  if( !_bezierGrowthSurface )
  {
    time += dt * surfTimeScale;
    int surf = 1;
    double surftime = 0;
    //while(time > surftime + surfTime[surf] && surf < surfaces - 1)
    //  surftime += surfTime[surf++ - 1];

    // setting for considering three bezier surfaces
    /*
    double halfTime = surfTime[surfaces-1]/2.;
    double maxTime = surfTime[surfaces-1];
    
    if( time < halfTime )
    {
      surf = 1;
      surfCurr.Interpolate( surface[surf-1], surface[surf], 
                            surfScale[surf-1], surfScale[surf],
                            (time - surftime)/halfTime );
    }
    else
    {
      surf = 2;
      surfCurr.Interpolate( surface[surf-1], surface[surf], 
                            surfScale[surf-1], surfScale[surf],
                            (time - surftime - halfTime)/halfTime );
    }
    */
    
    surfCurr.Interpolate( surface[surf-1], surface[surf], 
                          surfScale[surf-1], surfScale[surf],
                          (time - surftime)/surfTime[surf]);
  }
  else
  {
    time += dt;
    if( time > 1. )
      time = 1.;
    // determine the pair of considered surfaces depending on
    // the current time
    std::size_t min = 0;
    std::size_t max = _numSurfaces-1;
    double temp = (1.-time)*min + time*max;
    std::size_t curSurface = (std::size_t)temp;
    double tFactor = temp - (double)curSurface;
   
    /*
    std::cout << "time: " << time << std::endl;
    std::cout << "curSurface: " << curSurface << std::endl;
    std::cout << "tFactor: " << tFactor << std::endl;
    */
    
    if( curSurface != _numSurfaces-1 )
    {
      surfCurr.Interpolate( surface[curSurface], surface[curSurface+1], 
                            1., 1., tFactor);
    }
    else
      surfCurr = surface[curSurface];
  }
}

//----------------------------------------------------------------

double Surface::GetTime() const
{
	return time;
}

//----------------------------------------------------------------

// Get position at current time 
void Surface::GetPos(SurfacePoint &p)
{
  CalcPos(p);
  CalcNormal(p);
}

//----------------------------------------------------------------

// Return distance between u and v
double Surface::Distance(SurfacePoint &u, SurfacePoint &v)
{
  // For now use Euclidean distance
  return(norm(u.pos - v.pos));
}

//----------------------------------------------------------------

// Calculate xyz postition
void Surface::CalcPos(SurfacePoint &p)
{
  p.u = InBounds(p.u, 0.0, 1.0);
  p.v = InBounds(p.v, 0.0, 1.0);
  p.pos = surfCurr.EvalCoord(p.u, p.v);
}

//----------------------------------------------------------------

// Calculate normal
void Surface::CalcNormal(SurfacePoint &p)
{
  // Calc normal from surface.
  SurfacePoint n, s, e, w;
  n.u = p.u + DX; n.v = p.v; 
  s.u = p.u - DX; s.v = p.v;
  e.u = p.u; e.v = p.v + DX;
  w.u = p.u; w.v = p.v - DX;
  CalcPos(n); CalcPos(s);
  CalcPos(e); CalcPos(w);
    
  p.normal = s.Pos() - n.Pos();
  p.normal = p.normal ^ (w.Pos() - e.Pos());
  p.normal.normalize();
}
