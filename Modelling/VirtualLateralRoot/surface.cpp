// Implement surface and surface point class
#include "surface.h"

#include <string>
#include <iostream>
#include <fstream>
#include <iomanip> 

#include <cstdio>
#include <cmath>
#include <util/parms.h>

//----------------------------------------------------------------

void Surface::init( util::Parms &parms,
                    string section,
                    const bool bezierGrowthSurface,
                    const bool interpolateBezierSurfaces,
                    const bool onlyGrowthInHeight,
                    const std::string &surfaceName,
                    const std::size_t highOrderPattern )
{
  _time = 0.;
  
  string surffile;

  _bezierGrowthSurface = bezierGrowthSurface;
  
  // Load surfaces 
  parms(section.data(), "Surfaces", surfaces);
  parms(section.data(), "SurfTimeScale", surfTimeScale);
  parms(section.data(), "SurfMaxDist", surfMaxDist);
  if( !_bezierGrowthSurface )
  {
    for(int i = 0; i < surfaces; i++) {
      // Bezier surface
      std::ostringstream key;
      key << "Surface" << i;
      parms(section.data(), key.str().data(), surffile);
      surface[i].Load(surffile);
      // code to load bezier surface generated in MorphoGraphX
      //std::string name = surfaceName + std::to_string(i+1) + ".mgxv";
      //surface[i].Load( name );

      // Scaling constant
      key.str("");
      key << "SurfaceScale" << i;
      parms(section.data(), key.str().data(), surfScale[i]);

      // Time constant
      key.str("");
      key << "SurfaceTime" << i;
      parms(section.data(), key.str().data(), surfTime[i]);
    }
  }
  else
  {
    if( !interpolateBezierSurfaces )
    {
      std::string source = "/home/necrolyte/Data/VLR/Virtual_Lateral_Roots/Modelling/VirtualLateralRoot/bezierGrowthSurfaces/";
      this->determineSurfaceHeaderProperties( source + "header.txt" );
      
      for( std::size_t i = 0; i < _numSurfaces; i++ )
      {
        std::string digit;
        if( i < 10 )
          digit = "_00";
        else if( i < 100 )
          digit = digit = "_0";
        else
          digit = digit = "_";
        
        digit += std::to_string( i );
        std::string fileName = source + "bezierTensorSurface";
        fileName += digit;
        fileName += ".txt";
        
        // load bezier growth surface
        surface[i].LoadGrowthBezier( fileName, _numPatches, _numControlPoints );
      }
    }
    else
    {
      // Here, only load the first and last bezier surface while all surfaces
      // in between are generated by linear interpolation based on the number of
      // given surfaces numSurfaces
      std::string first = "bezierTensorSurfaceFirst.txt";
      std::string last = "bezierTensorSurfaceLast.txt";
      this->determineSurfaceHeaderProperties( "bezierHeader.txt" );
      
      // load bezier growth surfaces
      surface[0].LoadGrowthBezier( first, _numPatches, _numControlPoints );
      surface[_numSurfaces-1].LoadGrowthBezier( last, _numPatches, _numControlPoints );
      
      // highly support or impair the occurrence of the high order
      // pattern of periclinal divisions
      if( highOrderPattern != 0 )
        this->applyControlpointsVariation( surface[_numSurfaces-1], highOrderPattern == 2 );
      
      if( onlyGrowthInHeight )
        this->applyGrowthOnlyInHeight( surface[0], surface[_numSurfaces-1] );
      
      //this->increaseDomeTipHeight( surface[_numSurfaces-1] );
      
      for( std::size_t i = 1; i < _numSurfaces-1; i++ )
      {
        double s = (double)i/(double)(_numSurfaces-1);
        surface[i].Interpolate( surface[0], surface[_numSurfaces-1], 1., 1., s );
        surface[i].setCount( 1 );
      }
    }
  }
}

//----------------------------------------------------------------

void Surface::initRadialSurface( util::Parms &parms,
                                 string section )
{
  _bezierGrowthSurface = true;
  // Load surfaces 
  parms(section.data(), "Surfaces", surfaces);
  parms(section.data(), "SurfTimeScale", surfTimeScale);
  parms(section.data(), "SurfMaxDist", surfMaxDist);
  _time = 0.;
  _numSurfaces = 20;
  _numPatches = 1;
  _numControlPoints = 7;
  
  std::size_t mid = 10;
  
  // init first and last radial bezier surface
  surface[0].setRadialSurfaces( 0 );
  //surface[0].setRadialSurface( _numControlPoints, true );
  surface[0].setCount( 1 );
  surface[mid-1].setRadialSurfaces( 1 );
  surface[mid-1].setCount( 1 );
  surface[_numSurfaces-1].setRadialSurfaces( 2 );
  //surface[_numSurfaces-1].setRadialSurface( _numControlPoints, false );
  surface[_numSurfaces-1].setCount( 1 );
  
  for( std::size_t i = 1; i < _numSurfaces-1; i++ )
  {
    double s;
    
    if( i < mid-1 )
    {
      s = (double)i/(double)(mid-1);
      surface[i].Interpolate( surface[0], surface[mid-1], 1., 1., s );
      surface[i].setCount( 1 );
    }
    else if( i >= mid )
    {
      s = (double)(i-mid+1)/(double)(mid-1);
      surface[i].Interpolate( surface[mid-1], surface[_numSurfaces-1], 1., 1., s );
      surface[i].setCount( 1 );
    }
  }
  
//   for( std::size_t i = 1; i < _numSurfaces-1; i++ )
//   {
//     double s = (double)i/(double)(_numSurfaces-1);
//     surface[i].Interpolate( surface[0], surface[_numSurfaces-1], 1., 1., s );
//     surface[i].setCount( 1 );
//   }
}

//----------------------------------------------------------------

void Surface::increaseDomeTipHeight( Bezier &surface )
{
  surface.increaseDomeTipHeight( 270. );
}

//----------------------------------------------------------------

void Surface::applyGrowthOnlyInHeight( Bezier &surfaceS, const Bezier &surfaceE )
{
  surfaceS.applyGrowthOnlyInHeight( surfaceE );
}

//----------------------------------------------------------------

// only for bezier surfaces based on growth tensor
void Surface::determineSurfaceHeaderProperties( const std::string bezFile )
{
  std::ifstream bIn( bezFile.c_str() );
  if(!bIn) {
    cerr << "Bezier::Bezier:Error opening " << bezFile << endl;
    exit(1);
  }
  bIn >> _numSurfaces;
  bIn >> _numPatches;
  bIn >> _numControlPoints;
}

//----------------------------------------------------------------

void Surface::applyControlpointsVariation( Bezier &surface,
                                           const bool focusTop )
{
  // if focusTop == true, the upper control points except the
  // lowest ones are "growing" much faster towards the dome tip
  // else the most upper control points are "growing" towards
  // the dome tip while the lower ones "grow" much slower
  surface.focusCPs( focusTop );
}

//----------------------------------------------------------------

// Initial surface Point
void Surface::initPos( SurfacePoint &sp )
{
  sp.boundParameters();
  this->calcPos( sp );
  this->calcNormal( sp );
}

//----------------------------------------------------------------

// Determine parametric coords u and v such that the distance between
// the corresponding point for (u,v) is minimal to the desired point cp
void Surface::setPos( SurfacePoint &sp, const Point3d &cp )
{
  // Initial guess for p
  //p.u = sp.u;
  //p.v = sp.v;
  this->calcPos( sp );
  double lastd = -(DX * 1000);
  double count = 0;
  double du, dv;
  
  while( fabs(lastd - norm(cp - sp.pos)) > DX * 2. && count++ < MAXSEARCHSTEPS )
  {
    // Save previous distance
    lastd = norm(cp - sp.pos);

    // Calc partials
    SurfacePoint u1 = sp, u2 = sp;
    u1.u -= DX;
    u2.u += DX;
    this->calcPos( u1 );
    this->calcPos( u2 );
    du = (norm(cp - u1.pos) - norm(cp - u2.pos))/fabs(u1.u - u2.u);
    
    // make sure that the du values are in [0, 1] or [-1, 0] such that the line
    // minimization will not alternate between parametric values of 0 (left most)
    // and 1 (right most) because then the estimated parametric coordinates are
    // not computed correctly
    unsigned int numDigitsBeforeComma = std::to_string( abs( (int)(du) ) ).size();
    du /= (double)( pow( 10, numDigitsBeforeComma-1 ) );
    
    SurfacePoint v1 = sp, v2 = sp;
    v1.v -= DX;
    v2.v += DX;
    this->calcPos( v1 );
    this->calcPos( v2 );
    dv = (norm(cp - v1.pos) - norm(cp - v2.pos))/fabs(v1.v - v2.v);
    
    // make sure that the dv values are in [0, 1] or [-1, 0] such that the line
    // minimization will not alternate between parametric values of 0 (bottom most)
    // and 1 (top most) because then the estimated parametric coordinates are
    // not computed correctly
    numDigitsBeforeComma = std::to_string( abs( (int)(dv) ) ).size();
    dv /= (double)( pow( 10, numDigitsBeforeComma-1 ) );
    
    // Do line minimization
    double step = .01;
    while(step > DX)
    {
      SurfacePoint t = sp;
      t.u += step * du;
      t.v += step * dv;
      this->calcPos( t );
      if(norm(cp - t.pos) < norm(cp - sp.pos))
      {
        step *= 1.11;
        sp = t;
      }
      else
        step /= 2.0;
    }
  }

  this->calcNormal( sp );
  if(count >= MAXSEARCHSTEPS || norm(sp.pos - cp) > surfMaxDist) {
    std::cerr << "Surface::SetPoint:Error Failed, point " << cp << 
            " closest point " << sp.pos << " du " << du << " dv " << dv << 
            " count " << count << " distance " <<  norm(sp.pos - cp) << std::endl;
  }
}

//----------------------------------------------------------------

void Surface::growStep( const double dt )
{
  if( !_bezierGrowthSurface )
  {
    _time += dt * surfTimeScale;
    int surf = 1;
    double surftime = 0;
    
    surfCurr.Interpolate( surface[surf-1], surface[surf], 
                          surfScale[surf-1], surfScale[surf],
                          (_time - surftime)/surfTime[surf]);
  }
  else
  {
    _time += dt;
    if( _time > 1. )
      _time = 1.;
    // determine the pair of considered surfaces depending on
    // the current time
    std::size_t min = 0;
    std::size_t max = _numSurfaces-1;
    double temp = (1.-_time)*min + _time*max;
    std::size_t curSurface = (std::size_t)temp;
    double tFactor = temp - (double)curSurface;
    
    if( curSurface != _numSurfaces-1 )
    {
      surfCurr.Interpolate( surface[curSurface], surface[curSurface+1], 
                            1., 1., tFactor);
    }
    else
      surfCurr = surface[curSurface];
  }
}

//----------------------------------------------------------------

void Surface::getPos( SurfacePoint &sp )
{
  this->calcPos( sp );
  this->calcNormal( sp );
}

//----------------------------------------------------------------

void Surface::calcPos( SurfacePoint &sp )
{
  sp.boundParameters();
  sp.pos = surfCurr.EvalCoord( sp.u, sp.v );
}

//----------------------------------------------------------------

void Surface::calcNormal( SurfacePoint &sp )
{
  SurfacePoint n, s, e, w;
  n.u = sp.u + DX; n.v = sp.v; 
  s.u = sp.u - DX; s.v = sp.v;
  e.u = sp.u; e.v = sp.v + DX;
  w.u = sp.u; w.v = sp.v - DX;
  this->calcPos( n );
  this->calcPos( s );
  this->calcPos( e );
  this->calcPos( w );
    
  sp.normal = s.getPos() - n.getPos();
  sp.normal = sp.normal ^ (w.getPos() - e.getPos());
  sp.normal.normalize();
}
