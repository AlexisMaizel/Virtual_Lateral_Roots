#ifndef SurfacePoints_HH
#define SurfacePoints_HH

/**
  @file   SurfacePoints.h
  @brief  Class for handling triangulation of real data points
  @author Jens Fangerau <jens.fangerau@iwr.uni-heidelberg.de>
*/

#include <geometry/geometry.h>

#include <vector>
#include <fstream>

typedef util::Vector<2, double> Point2d;
typedef util::Vector<3, double> Point3d;
typedef util::Vector<3, std::size_t> Point3i;

const double eps = 0.000001;

class TrianglePoint
{
  public:
    TrianglePoint() : u(0.), v(0.), w(0.), triIndex(0){}
    ~TrianglePoint() {}

    Point2d Pos() { return pos; }
    Point2d Pos() const  { return pos; }
    Point3d Normal()  { return normal; }
    double getU() const { return u; }
    double getV() const { return v; }
    double getW() const { return w; }
    void setUVW( const double nu, const double nv, const double nw )
    { u = nu; v = nv; w = nw; }
    void setUVWT( const double nu, const double nv,
                  const double nw, const std::size_t ti )
    { u = nu; v = nv; w = nw; triIndex = ti; }
    std::size_t getTriIndex() const { return triIndex; }
    void printProperties() const
    {
      std::cout << "pos: " << pos << std::endl;
      std::cout << "u: " << u
                << " v: " << v
                << " w: " << w
                << " i: " << triIndex << std::endl;
    }
    void printPos() const
    { std::cout << "Point: [" << pos.i() << ", "
      << pos.j() << "]" << std::endl; }

    friend std::ostream& operator<<(std::ostream& os, const TrianglePoint &sp) {
      return os;
     };
    friend std::istream& operator>>(std::istream& is, TrianglePoint &sp) {
      return is;
    };
    friend class RealSurface;
    friend class SurfacePoints;

  private:
    double u,v,w;
    std::size_t triIndex;
    Point2d pos;
    Point3d normal;
};

//----------------------------------------------------------------

class SurfacePoints
{
public:
  
  SurfacePoints();
  void readTriangulation( const std::string &fileName );
  
  void getCoord( TrianglePoint &tp );
  
  void getBarycentricCoord( TrianglePoint &tp, const Point2d &p );
  
  void determineTriangleIndex( TrianglePoint &tp );
  
  void determinePosProperties( TrianglePoint &tp, const Point2d &p );
  
  bool findPointInTriangles( const Point2d &pos, TrianglePoint &tp );
  
  void determineNormal( TrianglePoint &tp );
  
  bool pointIsInTriangle( const Point2d &p, const Point2d &p0,
                          const Point2d &p1, const Point2d &p2 );
  void printTriangleProperties( const std::size_t timeStep );
  
  void interpolate( double timeStep );
  
  double checkBounds( double s, double min, double max ) ;
  
  std::size_t getNumTriangles() const
  { return _curTriangles.size(); }
  
  std::size_t getCurTimeStep() const
  { return _curTimeStep; }
  
private:
  
  // these are the 2D points for each cell position in time step t
  std::vector< std::vector<Point2d> > _points;
  // these are the mapped 2D points for each cell position in time step t+1
  // Note that if a cell bas been dividing in t+1 then we compute the average 
  //of the daughter's positions to get an unique mapping of cells from t to t+1
  std::vector< std::vector<Point2d> > _subsequentPoints;
  // these are the triangles of time step t generated by the list of indexes
  // to access _points
  std::vector< std::vector<Point3i> > _triangles;
  
  // these are the current 2D points for each cell position in the current time step
  std::vector<Point2d> _curPoints;
  // this is the current triangle list
  std::vector<Point3i> _curTriangles;
  
  std::size_t _minTimeStep;
  std::size_t _maxTimeStep;
  
  std::size_t _curTimeStep;
};

#endif // SurfacePoints_HH